use artemis.*
use fem.material.*

class Elastic3dFEM extends Node
	var in_u: InPortVectorField
	var in_dt_u: InPortVectorField
	
	var mat: Material
	
	
	func __init__()
		super.__init__("Elastic2dFEM")
		in_u.__init__(self, "u", PortFlags.MUTABLE)
		in_dt_u.__init__(self, "dt-u", PortFlags.MUTABLE)
		flags = NodeFlags.TIME_DEPENDENT
		
		mat = nickel()
	
	func mut substep(dt: f32, out ux: ScalarField, out uy: ScalarField, out uz: ScalarField, out dt_ux: ScalarField, out dt_uy: ScalarField, out dt_uz: ScalarField)
	#	print("---------------------")
	
	# i: C_ijkl d_j d_k u_l
	
		let dx_dx_ux = hessian_x(ux, 0, 0)
		let dx_dx_uy = hessian_x(uy, 0, 0)
		let dx_dx_uz = hessian_x(uz, 0, 0)
	
		let dx_dy_ux = hessian_x(ux, 0, 1)
		let dx_dy_uy = hessian_x(uy, 0, 1)
		let dx_dy_uz = hessian_x(uz, 0, 1)
	
		let dy_dy_ux = hessian_x(ux, 1, 1)
		let dy_dy_uy = hessian_x(uy, 1, 1)
		let dy_dy_uz = hessian_x(uz, 1, 1)
		
		var m: mat3
		m._11 = 1.0/mat.E.x
		m._22 = 1.0/mat.E.y
		m._33 = 1.0/mat.E.z
		m._12 = -mat.v.xy/mat.E.x
		m._23 = -mat.v.yz/mat.E.y
		m._13 = -mat.v.zx/mat.E.z
		m._21 = m._12
		m._32 = m._23
		m._31 = m._13
		let mi = m.inverse()
		
		let Cxxxx = mat.E.x #mi._11
		let Cyyyy = mat.E.y #mi._22
		let Czzzz = mat.E.z #mi._33
		let Cxxyy = 0#mi._12 # = Cyyxx
		let Cyyzz = 0#mi._23
		let Cxxzz = 0#mi._13
		let Cxyxy = mat.G.xy # = Cyxyx = Cxyyx = Cyxxy
		let Cyzyz = mat.G.yz
		let Cxzxz = mat.G.zx
	
		# xxxx + xxyy + (xxzz)   + xyxy + xyyx + (xzxz) + (xzzx)
#		var ddux_phi = dx_dx_ux_phi * Cxxxx + dx_dy_uy_phi * Cxxyy
#		ddux_phi += dx_dy_uy_phi * Cxyxy + dy_dy_ux_phi * Cxyxy
		# yyyy + yyxx + (yyzz)   + yxyx + yxxy + (yzyz) + (yzzy)
#		var dduy_phi = dy_dy_uy_phi * Cyyyy + dx_dy_ux_phi * Cxxyy
#		dduy_phi += dx_dy_ux_phi * Cxyxy + dx_dx_uy_phi * Cxyxy
		# (zzzz) + (zzxx) + (zzyy)   + (zxzx) + zxxz + (zyzy) + zyyz
#		let dduz_phi = dx_dx_uz_phi * Cxzxz + dy_dy_uz_phi * Cyzyz
		
		
		# xxxx + xxyy + (xxzz)   + xyxy + xyyx + (xzxz) + (xzzx)
		var ddux = dx_dx_ux * Cxxxx
		ddux += dx_dy_uy * Cxyxy + dy_dy_ux * Cxyxy
		# yyyy + yyxx + (yyzz)   + yxyx + yxxy + (yzyz) + (yzzy)
		var dduy = dy_dy_uy * Cyyyy
		dduy += dx_dy_ux * Cxyxy + dx_dx_uy * Cxyxy
		# (zzzz) + (zzxx) + (zzyy)   + (zxzx) + zxxz + (zyzy) + zyyz
		let dduz = dx_dx_uz * Cxzxz + dy_dy_uz * Cyzyz
		
	
		dt_ux += ddux * dt
		dt_uy += dduy * dt
		dt_uz += dduz * dt
		ux += dt_ux * dt
		uy += dt_uy * dt
		uz += dt_uz * dt
		#print(dux|>log)
	
	func override on_process()
		# assume f32
		# assume PER_VERTEX
		for u in in_u.value()
			for dt_u in in_dt_u.value()
			
				var ux = u.get_component(0)
				var uy = u.get_component(1)
				var uz = u.get_component(2)
				var dt_ux = dt_u.get_component(0)
				var dt_uy = dt_u.get_component(1)
				var dt_uz = dt_u.get_component(2)
		
				let dt = 0.0000002 #simulation_dt
				let N = 100
				for i in 0:N
					substep(dt / N, ux, uy, uz, dt_ux, dt_uy, dt_uz)
			
			
				u.set_component(0, ux)
				u.set_component(1, uy)
				u.set_component(2, uz)
				dt_u.set_component(0, dt_ux)
				dt_u.set_component(1, dt_uy)
				dt_u.set_component(2, dt_uz)
				in_u.mutated()
				in_dt_u.mutated()
	
		